package main

import (
	"bytes"
	"log"
	"text/template"

	"github.com/gotomicro/ego/internal/tools"
)

const (
	baseTpl = `
// svc generated by protoc-gen-go-test, you should not edit it.  
// @Overrid=true
var svc *egrpc.Component

// init generated by protoc-gen-go-test, you can fill initial logic by yourself.
// @Override=true
func init() {
	// initial your configuration、DB instance、Redis instance here.
}

// bufDialer generated by protoc-gen-go-test, you should not edit it.  
// @Override=true
func bufDialer(context.Context, string) (net.Conn, error) {
	return svc.Listener().(*bufconn.Listener).Dial()
}
`
	stream2streamTpl = `
// Test{{.Name}} generated by protoc-gen-go-test, you can fill test logic by yourself
// @Override=true
func Test{{.Name}}(t *testing.T) {
	cli := {{.Package}}.New{{.Service.Name}}Client(cegrpc.DefaultContainer().Build(cegrpc.WithDialOption(grpc.WithContextDialer(bufDialer))).ClientConn)
    ctx := context.Background()
	tests := []struct {
		name string
		req *{{.Package}}.{{.InType}}
		wantRes *{{.Package}}.{{.OutType}}
		wantErr error
	}{
		// TODO: Add or modify test cases.
		{"DefaultCase", &{{.Package}}.{{.InType}}{}, &{{.Package}}.{{.OutType}}{}, nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			stream, err := cli.{{.Name}}(ctx)
			assert.NoError(t, err)
			err = stream.Send(tt.req)
			assert.NoError(t, err)

			res, err := stream.Recv()
			assert.True(t, errors.Is(eerrors.FromError(err), tt.wantErr))
			assert.True(t, proto.Equal(tt.wantRes, res))
			t.Logf("res: %+v", res)
		})
	}
}

`
	unary2streamTpl = `
// Test{{.Name}} generated by protoc-gen-go-test, you can fill test logic by yourself.
// @Override=true
func Test{{.Name}}(t *testing.T) {
	cli := {{.Package}}.New{{.Service.Name}}Client(cegrpc.DefaultContainer().Build(cegrpc.WithDialOption(grpc.WithContextDialer(bufDialer))).ClientConn)
    ctx := context.Background()
	tests := []struct {
		name string
		req *{{.Package}}.{{.InType}}
		wantRes *{{.Package}}.{{.OutType}}
		wantErr error
	}{
		// TODO: Add or modify test cases.
		{"DefaultCase", &{{.Package}}.{{.InType}}{}, &{{.Package}}.{{.OutType}}{}, nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			stream, err := cli.{{.Name}}(ctx, tt.req)
			res, err := stream.Recv()
			assert.True(t, errors.Is(eerrors.FromError(err), tt.wantErr))
			assert.True(t, proto.Equal(tt.wantRes, res))
			t.Logf("res: %+v", res)
		})
	}
}

`
	stream2unaryTpl = `
// Test{{.Name}} generated by protoc-gen-go-test, you can fill test logic by yourself.
// @Override=true
func Test{{.Name}}(t *testing.T) {
	cli := {{.Package}}.New{{.Service.Name}}Client(cegrpc.DefaultContainer().Build(cegrpc.WithDialOption(grpc.WithContextDialer(bufDialer))).ClientConn)
    ctx := context.Background()

    stream, err := cli.{{.Name}}(ctx)
    assert.NoError(t, err)

	tests := []struct {
		name string
		req *{{.Package}}.{{.InType}}
		wantRes *{{.Package}}.{{.OutType}}
		wantErr error
	}{
		// TODO: Add or modify test cases.
		{"DefaultCase", &{{.Package}}.{{.InType}}{}, &{{.Package}}.{{.OutType}}{}, nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err = stream.Send(tt.req)
			assert.NoError(t, err)
			res, err := stream.CloseAndRecv()
			assert.True(t, errors.Is(eerrors.FromError(err), tt.wantErr))
			assert.True(t, proto.Equal(tt.wantRes, res))
			t.Logf("res: %+v", res)
		})
	}
}

`
	unary2unaryTpl = `
// Test{{.Name}} generated by protoc-gen-go-test, you can fill test logic by yourself.
// @Override=true
func Test{{.Name}}(t *testing.T) {
	cli := {{.Package}}.New{{.Service.Name}}Client(cegrpc.DefaultContainer().Build(cegrpc.WithDialOption(grpc.WithContextDialer(bufDialer))).ClientConn)
    ctx := context.Background()
	tests := []struct {
		name string
		req *{{.Package}}.{{.InType}}
		wantRes *{{.Package}}.{{.OutType}}
		wantErr error
	}{
		// TODO: Add or modify test cases.
		{"DefaultCase", &{{.Package}}.{{.InType}}{}, &{{.Package}}.{{.OutType}}{}, nil},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			res, err := cli.{{.Name}}(ctx, tt.req)
			assert.True(t, errors.Is(eerrors.FromError(err), tt.wantErr))
			assert.True(t, proto.Equal(tt.wantRes, res))
			t.Logf("res: %+v", res)
		})
	}
}

`
)

var tmpls = map[string]string{
	"stream_stream": stream2streamTpl,
	"stream_unary":  stream2unaryTpl,
	"unary_stream":  unary2streamTpl,
	"unary_unary":   unary2unaryTpl,
}

type svcData struct {
	Name              string
	Time              string
	InType            string
	OutType           string
	Package           string
	Service           service
	isStreamingServer bool
	isStreamingClient bool
}

type service struct {
	Name string
}

type svcWrapper struct {
	Svcs []*svcData
}

func (s svcData) tmpl() string {
	var srv, cli string
	if s.isStreamingServer {
		srv = "stream"
	} else {
		srv = "unary"
	}

	if s.isStreamingClient {
		cli = "stream"
	} else {
		cli = "unary"
	}

	return tmpls[cli+"_"+srv]
}

func (w *svcWrapper) execute() string {
	buf := new(bytes.Buffer)

	tpl := template.New("test")
	for _, svc := range w.Svcs {
		err := template.Must(tpl.Parse(svc.tmpl())).Execute(buf, svc)
		if err != nil {
			log.Fatal("render tmpl fail", err)
			return ""
		}
	}
	return string(tools.GoFmt(buf.Bytes()))
}
